# Transport Layer Architecture

The transport layer provides a unified interface over multiple protocols via a clean abstraction. Whether you're using HTTP, WebSocket, or custom protocols, the same middleware, configuration patterns, and client APIs apply. This abstraction enables protocol-specific optimizations while maintaining consistency across languages and use cases.

## Core Architecture

```
┌─────────────────────────────────────────┐
│ Protocol-Specific Transport             │  ← HTTP, WebSocket, Custom
│ (with optional middleware)              │
├─────────────────────────────────────────┤
│ Base Transport Abstraction              │  ← Generic TransportT trait
└─────────────────────────────────────────┘
```

## Key Benefits

### 1. **Protocol Agnostic**
- Same interface works for HTTP, WebSocket, gRPC, or custom protocols
- Easy to add new transport types without changing client code
- Consistent API across all communication methods

### 2. **Multi-Language Support**
- Core logic implemented once in Rust for maximum performance
- Python and Node.js bindings provide native language APIs
- Type-safe configuration across all languages

### 3. **Middleware System**
- Composable middleware layers for cross-cutting concerns
- Logging, retry, authentication, rate limiting, etc.
- Same middleware works across all transport types

## Languages

- Rust (native)
- Python (bindings)
- TypeScript/Node.js (bindings)

## Transport Types

Choose a transport type to learn more:

- **[HTTP Transport](1.1-http-transport.md)** - HTTP client with connection pooling and HTTP/2 support
- **[WebSocket Transport](1.2-ws-transport.md)** - Bidirectional communication with pub/sub message patterns
