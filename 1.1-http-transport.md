# HTTP Transport

This document describes the HTTP stack with a layered architecture: base transport abstraction → protocol implementation → middleware system → client API. The same design is available in Rust, Python, and Node.js.

## Architecture Overview

The HTTP transport follows a bottom-to-top layered architecture, building from the core transport abstraction up to high-level client APIs:

```
┌─────────────────────────────────────────┐
│ Base Transport (sb-stack-transport)     │  ← Core abstraction
├─────────────────────────────────────────┤
│ HTTP Transport (sb-stack-transport-http)│  ← Protocol-specific implementation
│ (with optional middleware)              │
├─────────────────────────────────────────┤
│ HTTP Client (sb-http-client)            │  ← High-level API
└─────────────────────────────────────────┘
```

## Usage

### 1.1 Rust

```rust
use sb_stack_transport_http::{HttpTransport, Http1TransportConfig, HttpTransportRequestPacket};
use http::Method;
use url::Url;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let base_url = Url::parse("https://httpbin.org")?;
    let mut transport = HttpTransport::new(base_url.clone(), Http1TransportConfig::default(), None);
    transport.connect().await?;

    let mut request = HttpTransportRequestPacket::new(Method::GET);
    request.set_url(Some(base_url.join("/get?foo=bar")?));

    let response = transport.call(request).await?;

    println!("Status: {}", response.status());
    println!("Body: {:?}", response.body());

    Ok(())
}
```

### 1.2 Python

```python
import asyncio
from sb_http_client import HttpClient

async def main():
    client = HttpClient("https://httpbin.org")
    response = await client.get("/get", params={"foo": "bar"})
    print(f"Status: {response.status}")
    print(f"Body: {response.json()}")
    await client.close()

asyncio.run(main())
```

### 1.3 TypeScript

```typescript
import { HttpClient } from 'sb-http-client';

async function main() {
    const client = new HttpClient({
        baseURL: 'https://httpbin.org'
    });

    const response = await client.get('/get', {
        params: { foo: 'bar' }
    });

    console.log('Status:', response.status);
    console.log('Body:', response.data);
}

main().catch(console.error);
```

## Performance Benchmarks

#### Node.js Comparison

> **Benchmarks with undici bench suite** Using undici's established benchmark methodology ensures fair, reproducible comparisons that align with industry-standard practices and eliminate measurement bias. This provides credible performance validation to demonstrate that our Rust-based implementation delivers meaningful improvements over the fastest JavaScript-native option. See [undici's benchmark suite](https://github.com/nodejs/undici?tab=readme-ov-file#benchmarks) for the complete methodology.

| Client | RPS | vs sb-stack |
|--------|-----|-------------|
| **sb-http-client** | **26,843** | **1.00x** |
| undici-request | 24,770 | 1.08x slower |
| undici-stream | 21,608 | 1.24x slower |
| axios | 5,424 | **4.9x slower** |
| node-fetch | 5,527 | 4.8x slower |

#### Python Comparison

| Client | RPS | vs sb-stack |
|--------|-----|-------------|
| aiohttp | 5,391 | 1.045x faster |
| **sb-stack** | **5,160** | **1.00x** |
| httpx | 561 | **7.2x slower** |

### Why These Numbers

The performance is achieved through:
- Rust implementation: No garbage collection overhead, efficient async I/O
- Architecture: Middleware runs in Rust, connection pooling, request pipelining
- Type system: Compile-time composition

## Middleware

### 1.1 Rust

```rust
use sb_stack_transport_http::{HttpTransport, Http1TransportConfig, HttpTransportRequestPacket};
use sb_stack_logging_middleware::{LoggingMiddleware, LogLevel};
use sb_stack_transport::BoxTransportLayerService;
use http::Method;
use url::Url;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let logging = LoggingMiddleware::new(LogLevel::Info)
        .with_request_params(true)
        .with_response_results(true);

    let middlewares: Vec<BoxTransportLayerService<_, _>> = vec![
        Box::new(logging),
    ];

    let base_url = Url::parse("https://httpbin.org")?;
    let mut transport = HttpTransport::new(base_url, Http1TransportConfig::default(), Some(middlewares));
    transport.connect().await?;

    let mut request = HttpTransportRequestPacket::new(Method::GET);
    request.set_url(Some(Url::parse("https://httpbin.org/get?foo=bar")?));

    let response = transport.call(request).await?;

    println!("Status: {}", response.status());

    Ok(())
}
```

### 1.2 Python

```python
from sb_http_client import HttpClient ,LoggingMiddleware, LogLevel

logging = LoggingMiddleware(
    level=LogLevel.INFO,
    log_request_params=True,
    log_response_results=True
)

client = HttpClient("https://httpbin.org", middlewares=[logging])
response = client.get("/get", params={"foo": "bar"})
print(f"Status: {response.status}")
print(f"Body: {response.json()}")
client.close()
```

### 1.3 TypeScript

```typescript
import { HttpClient} from 'sb-http-client';
import {  LoggingMiddleware, LogLevel } from 'sb-http-client';

const logging = new LoggingMiddleware({
    level: LogLevel.INFO,
    logRequestParams: true,
    logResponseResults: true
});

async function main() {
    const client = new HttpClient({
        baseURL: 'https://httpbin.org',
        middlewares: [logging]
    });

    const response = await client.get('/get', {
        params: { foo: 'bar' }
    });

    console.log('Status:', response.status);
    console.log('Body:', response.data);
}

main().catch(console.error);
```

## Additional Usage Patterns

Python supports multiple usage patterns for different scenarios:

### Sync

```python
from sb_http_client import HttpClient

client = HttpClient("https://httpbin.org")
response = client.get("/get", params={"foo": "bar"})
print(f"Status: {response.status}")
print(f"Body: {response.json()}")
client.close()
```

### Sync Context Manager

```python
from sb_http_client import HttpClient

with HttpClient("https://httpbin.org") as client:
    response = client.get("/get", params={"foo": "bar"})
    print(f"Status: {response.status}")
    print(f"Body: {response.json()}")
```

### Async Context Manager

```python
import asyncio
from sb_http_client import HttpClient

async def main():
    async with HttpClient("https://httpbin.org") as client:
        response = await client.get("/get", params={"foo": "bar"})
        print(f"Status: {response.status}")
        print(f"Body: {response.json()}")

asyncio.run(main())
```

## Configuration

The HTTP transport supports both HTTP/1.1 and HTTP/2 protocols with comprehensive configuration options for connection management, timeouts, retries, security, and compression.

### HTTP/1.1 Configuration

#### 1.1 Rust

```rust
use sb_stack_transport_http::{
    HttpTransport,
    Http1TransportConfig,Accepts,
    DnsConfig,
    ProxyConfig,
    RedirectPolicy,
    ConnectionConfig,
    TlsConfig
};
use std::time::Duration;
use http::HeaderMap;

let connection_config = ConnectionConfig {
    connection_timeout: Some(Duration::from_secs(30)),
    pool_idle_timeout: Some(Duration::from_secs(90)),
    pool_max_idle_per_host: 32,
    tcp_keepalive: Some(Duration::from_secs(60)),
    tcp_keepalive_interval: Some(Duration::from_secs(30)),
    tcp_keepalive_retries: Some(3),
    nodelay: true,
    local_address: None,
    connection_verbose: false,
};

let tls_config = TlsConfig {
    hostname_verification: true,
    certs_verification: true,
    use_sni: true,
    min_tls_version: None,
    max_tls_version: None,
    accept_invalid_certs: false,
    accept_invalid_hostnames: false,
    disable_built_in_roots: false,
    root_certificates: Vec::new(),
    identity: None,
    alpn_protocols: Some(vec!["h2".to_string(), "http/1.1".to_string()]),
    tls_info: false,
};

let http1_config = Http1Config {
    title_case_headers: false,
    http09_responses: false,
    allow_obsolete_multiline_headers: false,
    ignore_invalid_headers: false,
    allow_spaces_after_header_name: false,
};

let config = Http1TransportConfig {
    headers: {
        let mut headers = HeaderMap::new();
        headers.insert("User-Agent", "MyApp/1.0".parse()?);
        headers.insert("Accept", "application/json".parse()?);
        headers
    },
    accepts: Accepts {
        gzip: true,
        brotli: false,
        deflate: false,
        zstd: false,
    },
    timeout: Some(Duration::from_secs(30)),
    read_timeout: Some(Duration::from_secs(30)),
    redirect_policy: RedirectPolicy::Limited(10),
    referer: true,
    https_only: true,
    connection_config,
    tls_config,
    proxy_config: ProxyConfig::default(),
    dns_config: DnsConfig::default(),
    protocol_config: http1_config,
};
```

#### 1.2 Python

```python
from sb_stack_transport_http import (
    Http1TransportConfig,
    ConnectionConfig,
    TlsConfig,
    Http1Config,
    Accepts,
    DnsConfig,
    ProxyConfig,
    RedirectPolicy
    )

connection_config = ConnectionConfig(
    connection_timeout=30.0,
    pool_idle_timeout=90.0,
    pool_max_idle_per_host=32,
    tcp_keepalive=60.0,
    tcp_keepalive_interval=30.0,
    tcp_keepalive_retries=3,
    nodelay=True,
    local_address=None,
    connection_verbose=False,
)

tls_config = TlsConfig(
    hostname_verification=True,
    certs_verification=True,
    use_sni=True,
    min_tls_version=None,
    max_tls_version=None,
    accept_invalid_certs=False,
    accept_invalid_hostnames=False,
    disable_built_in_roots=False,
    root_certificates=[],
    identity=None,
    alpn_protocols=["h2", "http/1.1"],
    tls_info=False,
)

http1_config = Http1Config(
    title_case_headers=False,
    http09_responses=False,
    allow_obsolete_multiline_headers=False,
    ignore_invalid_headers=False,
    allow_spaces_after_header_name=False,
)

config = Http1TransportConfig(
    headers={
        "User-Agent": "MyApp/1.0",
        "Accept": "application/json"
    },
    accepts=Accepts(
        gzip=True,
        brotli=False,
        deflate=False,
        zstd=False
    ),
    timeout=30.0,
    read_timeout=30.0,
    redirect_policy=RedirectPolicy.Limited(10),
    referer=True,
    https_only=True,
    connection_config=connection_config,
    tls_config=tls_config,
    proxy_config=ProxyConfig(),
    dns_config=DnsConfig(),
    protocol_config=http1_config,
)
```

#### 1.3 TypeScript

```typescript
import { Http1TransportConfig ,ConnectionConfig, TlsConfig, Http1Config ,Accepts, DnsConfig, ProxyConfig, RedirectPolicy  } from 'sb-stack-transport-http';

const connectionConfig = new ConnectionConfig({
    connectionTimeout: 30000,
    poolIdleTimeout: 90000,
    poolMaxIdlePerHost: 32,
    tcpKeepalive: 60000,
    tcpKeepaliveInterval: 30000,
    tcpKeepaliveRetries: 3,
    nodelay: true,
    localAddress: null,
    connectionVerbose: false,
});

const tlsConfig = new TlsConfig({
    hostnameVerification: true,
    certsVerification: true,
    useSni: true,
    minTlsVersion: null,
    maxTlsVersion: null,
    acceptInvalidCerts: false,
    acceptInvalidHostnames: false,
    disableBuiltInRoots: false,
    rootCertificates: [],
    identity: null,
    alpnProtocols: ["h2", "http/1.1"],
    tlsInfo: false,
});

const http1Config = new Http1Config({
    titleCaseHeaders: false,
    http09Responses: false,
    allowObsoleteMultilineHeaders: false,
    ignoreInvalidHeaders: false,
    allowSpacesAfterHeaderName: false,
});

const config = new Http1TransportConfig({
    headers: {
        'User-Agent': 'MyApp/1.0',
        'Accept': 'application/json'
    },
    accepts: new Accepts({
        gzip: true,
        brotli: false,
        deflate: false,
        zstd: false
    }),
    timeout: 30000,
    readTimeout: 30000,
    redirectPolicy: RedirectPolicy.Limited(10),
    referer: true,
    httpsOnly: true,
    connectionConfig: connectionConfig,
    tlsConfig: tlsConfig,
    proxyConfig: new ProxyConfig(),
    dnsConfig: new DnsConfig(),
    protocolConfig: http1Config,
});
```

### HTTP/2 Configuration

#### 1.1 Rust

```rust
use sb_stack_transport_http::{HttpTransport, Http2TransportConfig};
use sb_stack_transport_types::{
    connection::ConnectionConfig,
    tls::TlsConfig,
    http::Http2Config,
};
use sb_stack_transport_http::reqwest_http::configs::{
    Accepts, DnsConfig, ProxyConfig, RedirectPolicy
};
use std::time::Duration;
use http::HeaderMap;

let connection_config = ConnectionConfig {
    connection_timeout: Some(Duration::from_secs(30)),
    pool_idle_timeout: Some(Duration::from_secs(90)),
    pool_max_idle_per_host: 32,
    tcp_keepalive: Some(Duration::from_secs(60)),
    tcp_keepalive_interval: Some(Duration::from_secs(30)),
    tcp_keepalive_retries: Some(3),
    nodelay: true,
    local_address: None,
    connection_verbose: false,
};

let tls_config = TlsConfig {
    hostname_verification: true,
    certs_verification: true,
    use_sni: true,
    min_tls_version: None,
    max_tls_version: None,
    accept_invalid_certs: false,
    accept_invalid_hostnames: false,
    disable_built_in_roots: false,
    root_certificates: Vec::new(),
    identity: None,
    alpn_protocols: Some(vec!["h2".to_string()]),
    tls_info: false,
};

let http2_config = Http2Config {
    adaptive_window: true,
    initial_stream_window_size: 16 * 1024 * 1024,
    initial_connection_window_size: 16 * 1024 * 1024,
    max_frame_size: Some(16 * 1024),
    max_header_list_size: 64 * 1024,
    keep_alive_interval: Some(Duration::from_secs(30)),
    keep_alive_timeout: Some(Duration::from_secs(10)),
    keep_alive_while_idle: true,
};

let config = Http2TransportConfig {
    headers: {
        let mut headers = HeaderMap::new();
        headers.insert("User-Agent", "MyApp/1.0".parse()?);
        headers.insert("Accept", "application/json".parse()?);
        headers
    },
    accepts: Accepts {
        gzip: true,
        brotli: false,
        deflate: false,
        zstd: false,
    },
    timeout: Some(Duration::from_secs(30)),
    read_timeout: Some(Duration::from_secs(30)),
    redirect_policy: RedirectPolicy::Limited(10),
    referer: true,
    https_only: true,
    connection_config,
    tls_config,
    proxy_config: ProxyConfig::default(),
    dns_config: DnsConfig::default(),
    protocol_config: http2_config,
};
```

#### 1.2 Python

```python
from sb_stack_transport_http import Http2TransportConfig
from sb_stack_transport_types import ConnectionConfig, TlsConfig, Http2Config
from sb_stack_transport_http.reqwest_http.configs import Accepts, DnsConfig, ProxyConfig, RedirectPolicy

connection_config = ConnectionConfig(
    connection_timeout=30.0,
    pool_idle_timeout=90.0,
    pool_max_idle_per_host=32,
    tcp_keepalive=60.0,
    tcp_keepalive_interval=30.0,
    tcp_keepalive_retries=3,
    nodelay=True,
    local_address=None,
    connection_verbose=False,
)

tls_config = TlsConfig(
    hostname_verification=True,
    certs_verification=True,
    use_sni=True,
    min_tls_version=None,
    max_tls_version=None,
    accept_invalid_certs=False,
    accept_invalid_hostnames=False,
    disable_built_in_roots=False,
    root_certificates=[],
    identity=None,
    alpn_protocols=["h2"],
    tls_info=False,
)

http2_config = Http2Config(
    adaptive_window=True,
    initial_stream_window_size=16 * 1024 * 1024,
    initial_connection_window_size=16 * 1024 * 1024,
    max_frame_size=16 * 1024,
    max_header_list_size=64 * 1024,
    keep_alive_interval=30.0,
    keep_alive_timeout=10.0,
    keep_alive_while_idle=True,
)

config = Http2TransportConfig(
    headers={
        "User-Agent": "MyApp/1.0",
        "Accept": "application/json"
    },
    accepts=Accepts(
        gzip=True,
        brotli=False,
        deflate=False,
        zstd=False
    ),
    timeout=30.0,
    read_timeout=30.0,
    redirect_policy=RedirectPolicy.Limited(10),
    referer=True,
    https_only=True,
    connection_config=connection_config,
    tls_config=tls_config,
    proxy_config=ProxyConfig(),
    dns_config=DnsConfig(),
    protocol_config=http2_config,
)
```

#### 1.3 TypeScript

```typescript
import { Http2TransportConfig } from 'sb-stack-transport-http';
import { ConnectionConfig, TlsConfig, Http2Config } from 'sb-stack-transport-types';
import { Accepts, DnsConfig, ProxyConfig, RedirectPolicy } from 'sb-stack-transport-http/reqwest_http/configs';

const connectionConfig = new ConnectionConfig({
    connectionTimeout: 30000,
    poolIdleTimeout: 90000,
    poolMaxIdlePerHost: 32,
    tcpKeepalive: 60000,
    tcpKeepaliveInterval: 30000,
    tcpKeepaliveRetries: 3,
    nodelay: true,
    localAddress: null,
    connectionVerbose: false,
});

const tlsConfig = new TlsConfig({
    hostnameVerification: true,
    certsVerification: true,
    useSni: true,
    minTlsVersion: null,
    maxTlsVersion: null,
    acceptInvalidCerts: false,
    acceptInvalidHostnames: false,
    disableBuiltInRoots: false,
    rootCertificates: [],
    identity: null,
    alpnProtocols: ["h2"],
    tlsInfo: false,
});

const http2Config = new Http2Config({
    adaptiveWindow: true,
    initialStreamWindowSize: 16 * 1024 * 1024,
    initialConnectionWindowSize: 16 * 1024 * 1024,
    maxFrameSize: 16 * 1024,
    maxHeaderListSize: 64 * 1024,
    keepAliveInterval: 30000,
    keepAliveTimeout: 10000,
    keepAliveWhileIdle: true,
});

const config = new Http2TransportConfig({
    headers: {
        'User-Agent': 'MyApp/1.0',
        'Accept': 'application/json'
    },
    accepts: new Accepts({
        gzip: true,
        brotli: false,
        deflate: false,
        zstd: false
    }),
    timeout: 30000,
    readTimeout: 30000,
    redirectPolicy: RedirectPolicy.Limited(10),
    referer: true,
    httpsOnly: true,
    connectionConfig: connectionConfig,
    tlsConfig: tlsConfig,
    proxyConfig: new ProxyConfig(),
    dnsConfig: new DnsConfig(),
    protocolConfig: http2Config,
});
```

### Configuration Options Summary

#### Common Options (HTTP/1.1 & HTTP/2)

| Option | Description | Default |
|--------|-------------|---------|
| `timeout` | Request timeout | None |
| `read_timeout` | Read operation timeout | None |
| `https_only` | Enforce HTTPS | false |
| `referer` | Set Referer header on redirects | true |
| `redirect_policy` | Redirect handling policy | Limited(10) |

#### Connection Configuration

| Option | Description | Default |
|--------|-------------|---------|
| `connection_timeout` | Connection establishment timeout | None |
| `pool_idle_timeout` | Idle connection timeout | 90s |
| `pool_max_idle_per_host` | Max idle connections per host | usize::MAX |
| `tcp_keepalive` | TCP keep-alive interval | 15s |
| `tcp_keepalive_interval` | TCP keep-alive interval | 15s |
| `tcp_keepalive_retries` | TCP keep-alive retries | 3 |
| `nodelay` | Disable Nagle's algorithm | true |
| `local_address` | Local address to bind to | None |
| `connection_verbose` | Enable connection logging | false |

#### TLS Configuration

| Option | Description | Default |
|--------|-------------|---------|
| `hostname_verification` | Verify hostname | true |
| `certs_verification` | Verify certificates | true |
| `use_sni` | Use SNI | true |
| `accept_invalid_certs` | Accept invalid certificates | false |
| `accept_invalid_hostnames` | Accept invalid hostnames | false |
| `disable_built_in_roots` | Disable built-in root certs | false |
| `alpn_protocols` | ALPN protocol list | None |
| `tls_info` | Enable TLS info logging | false |

#### Compression Options

| Option | Description | Default |
|--------|-------------|---------|
| `gzip` | Enable gzip compression | true |
| `brotli` | Enable brotli compression | true |
| `deflate` | Enable deflate compression | true |
| `zstd` | Enable zstd compression | true |

#### HTTP/1.1 Specific Options

| Option | Description | Default |
|--------|-------------|---------|
| `title_case_headers` | Use title case headers | false |
| `http09_responses` | Allow HTTP/0.9 responses | false |
| `allow_obsolete_multiline_headers` | Allow obsolete multiline headers | false |
| `ignore_invalid_headers` | Ignore invalid headers | false |
| `allow_spaces_after_header_name` | Allow spaces after header name | false |

#### HTTP/2 Specific Options

| Option | Description | Default |
|--------|-------------|---------|
| `adaptive_window` | Enable adaptive window sizing | true |
| `initial_stream_window_size` | Initial stream window size | 16MB |
| `initial_connection_window_size` | Initial connection window size | 16MB |
| `max_frame_size` | Maximum frame size | 16KB |
| `max_header_list_size` | Maximum header list size | 64KB |
| `keep_alive_interval` | Keep-alive ping interval | 30s |
| `keep_alive_timeout` | Keep-alive timeout | 10s |
| `keep_alive_while_idle` | Keep-alive while idle | true |
