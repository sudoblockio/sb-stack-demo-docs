---
title: "JSON-RPC Service"
description: "JSON-RPC 2.0 protocol implementation with HTTP transport support"
nav_order: 5
---

# JSON-RPC Service

This document describes the JSON-RPC 2.0 service built on the HTTP transport layer.

## Architecture Overview

The JSON-RPC service follows a layered architecture built on the HTTP transport:

```
┌─────────────────────────────────────────┐
│ JSON-RPC Service                        │  ← Protocol-specific implementation
│ (with optional service middleware)      │
├─────────────────────────────────────────┤
│ HTTP Transport (sb-stack-transport-http)│  ← Transport layer
│ (with optional transport middleware)    │
├─────────────────────────────────────────┤
│ Network                                 │  ← Network communication
└─────────────────────────────────────────┘
```

**Request Flow:** JSON-RPC Service → [Service Middleware] → HTTP Transport → [Transport Middleware] → Network

**Response Flow:** Network → [Transport Middleware] → HTTP Transport → [Service Middleware] → JSON-RPC Service

## Usage

### 1.1 Rust

```rust
use sb_stack_jsonrpc::{JsonRpcService, JsonRpcServiceConfig};
use sb_stack_jsonrpc_types::{JsonRpcServiceRequest, JsonrpcId};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = JsonRpcServiceConfig::new("https://httpbin.org/post");
    let mut service = JsonRpcService::new(config)?;
    service.connect().await?;
    
    let request = JsonRpcServiceRequest {
        id: JsonrpcId::Number(1),
        method: "echo".to_string(),
        params: Some(json!({"text": "hello"})),
        url: None,
        headers: HeaderMap::new(),
        extra: HashMap::new(),
        extensions: Extensions::new(),
        _response_type: std::marker::PhantomData::<serde_json::Value>,
    };
    
    let responses = service.call(vec![request]).await?;
    
    for response in responses {
        if let Some(result) = response.result {
            println!("Result: {}", result);
        }
    }
    
    Ok(())
}
```

### 1.2 Python

```python
import asyncio
from sb_stack_jsonrpc import PyJsonrpcService, JsonRpcServiceConfig, JsonRpcServiceRequest

async def main():
    config = JsonRpcServiceConfig("https://httpbin.org/post")
    service = PyJsonrpcService(config)
    await service.connect()
    
    request = JsonRpcServiceRequest("echo", {"text": "hello"})
    response = await service.call(request)
    
    if response.result:
        print(f"Result: {response.result}")
    
    await service.close()

asyncio.run(main())
```

### 1.3 TypeScript

```typescript
import { JsonrpcService, JsonRpcServiceConfig, JsonRpcServiceRequest } from 'sb-stack-jsonrpc';

async function main() {
    const config = new JsonRpcServiceConfig("https://httpbin.org/post");
    const service = new JsonrpcService(config);
    
    await service.connect();
    
    const request = new JsonRpcServiceRequest(
        "1",
        "echo",
        { text: "hello" },
        null,
        null
    );
    
    const response = await service.call(request);
    
    if (response.is_success()) {
        const result = response.extract_result();
        console.log("Result:", result);
    }
    
    await service.close();
}

main().catch(console.error);
```

## Middleware

### 1.1 Rust

```rust
use sb_stack_jsonrpc::{JsonRpcService, JsonRpcServiceConfig};
use sb_stack_logging_middleware::{LoggingMiddleware, LogLevel};
use sb_stack_jsonrpc_types::{JsonRpcServiceRequest, JsonrpcId};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let logging = LoggingMiddleware::new(LogLevel::Info)
        .with_request_params(true)
        .with_response_results(true);
    
    let config = JsonRpcServiceConfig::new("https://httpbin.org/post")
        .with_middleware(logging);
    
    let mut service = JsonRpcService::new(config)?;
    service.connect().await?;
    
    let request = JsonRpcServiceRequest {
        id: JsonrpcId::Number(1),
        method: "echo".to_string(),
        params: Some(json!({"text": "hello"})),
        url: None,
        headers: HeaderMap::new(),
        extra: HashMap::new(),
        extensions: Extensions::new(),
        _response_type: std::marker::PhantomData::<serde_json::Value>,
    };
    
    let responses = service.call(vec![request]).await?;
    
    Ok(())
}
```

### 1.2 Python

```python
import asyncio
from sb_stack_jsonrpc import PyJsonrpcService, JsonRpcServiceConfig, JsonRpcServiceRequest
from sb_stack_logging_middleware import LoggingMiddleware, LogLevel

logging = LoggingMiddleware(
    level=LogLevel.INFO,
    log_request_params=True,
    log_response_results=True
)

async def main():
    config = JsonRpcServiceConfig(
        "https://httpbin.org/post",
        middlewares=[logging]
    )
    service = PyJsonrpcService(config)
    await service.connect()
    
    request = JsonRpcServiceRequest("echo", {"text": "hello"})
    response = await service.call(request)
    
    await service.close()

asyncio.run(main())
```

### 1.3 TypeScript

```typescript
import { 
    JsonrpcService,
    JsonRpcServiceConfig, 
    JsonRpcServiceRequest, 
    LoggingMiddleware,
    LogLevel 
} from 'sb-stack-jsonrpc';

const logging = new LoggingMiddleware({
    level: LogLevel.INFO,
    logRequestParams: true,
    logResponseResults: true
});

async function main() {
    const config = new JsonRpcServiceConfig(
        "https://httpbin.org/post",
        [logging],
        null,
        null,
        null
    );
    const service = new JsonrpcService(config);
    
    await service.connect();
    
    const request = new JsonRpcServiceRequest(
        "1",
        "echo",
        { text: "hello" },
        null,
        null
    );
    
    const response = await service.call(request);
    
    await service.close();
}

main().catch(console.error);
```

## Batch Processing

JSON-RPC batch processing for multiple requests in a single call.

### 1.1 Rust

```rust
use sb_stack_jsonrpc_batch::{BatchService, BatchConfig};
use sb_stack_jsonrpc::{JsonRpcService, JsonRpcServiceConfig};
use sb_stack_jsonrpc_types::JsonRpcServiceRequest;
use serde_json::json;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let jsonrpc_service = JsonRpcService::new(
        JsonRpcServiceConfig::new("https://httpbin.org/post")
    )?;
    
    let batch_config = BatchConfig {
        max_batch_size: 50,
    };
    
    let batch_service = BatchService::new(jsonrpc_service, batch_config);
    let handle = batch_service.handle();
    
    let request = JsonRpcServiceRequest::new("echo", Some(json!({"text": "hello"})));
    let response = handle.add_request(request).await?;
    
    Ok(())
}
```


## Additional Usage Patterns

Python supports multiple usage patterns for different scenarios:

### Sync

```python
from sb_stack_jsonrpc import PyJsonrpcService, JsonRpcServiceConfig, JsonRpcServiceRequest

config = JsonRpcServiceConfig("https://httpbin.org/post")
service = PyJsonrpcService(config)
service.connect()

request = JsonRpcServiceRequest("echo", {"text": "hello"})
response = service.call(request)

if response.result:
    print(f"Result: {response.result}")

service.close()
```

### Sync Context Manager

```python
from sb_stack_jsonrpc import PyJsonrpcService, JsonRpcServiceConfig, JsonRpcServiceRequest

config = JsonRpcServiceConfig("https://httpbin.org/post")
service = PyJsonrpcService(config)

with service:
    service.connect()
    request = JsonRpcServiceRequest("echo", {"text": "hello"})
    response = service.call(request)
    
    if response.result:
        print(f"Result: {response.result}")
```

### Async Context Manager

```python
import asyncio
from sb_stack_jsonrpc import JsonrpcService, JsonRpcServiceConfig, JsonRpcServiceRequest

async def main():
    config = JsonRpcServiceConfig("https://httpbin.org/post")
    service = JsonrpcService(config)
    await service.connect()
    
    try:
        request = JsonRpcServiceRequest("echo", {"text": "hello"})
        response = await service.call(request)
        
        if response.result:
            print(f"Result: {response.result}")
    finally:
        await service.close()

asyncio.run(main())
```


## Configuration

The JSON-RPC service supports configuration for transport settings, timeouts, and connection management.

#### 1.1 Rust

```rust
use sb_stack_jsonrpc::JsonRpcServiceConfig;
use sb_stack_transport_http::Http1TransportConfig;
use sb_stack_transport_types::ConnectionConfig;
use std::time::Duration;

let transport_config = Http1TransportConfig {
    timeout: Some(Duration::from_secs(30)),
    connection_config: ConnectionConfig {
        pool_max_idle_per_host: 32,
        pool_idle_timeout: Some(Duration::from_secs(90)),
        tcp_keepalive: Some(Duration::from_secs(60)),
        ..Default::default()
    },
    ..Default::default()
};

let mut config = JsonRpcServiceConfig::new("https://httpbin.org/post");
config.config = Some(transport_config);
```

#### 1.2 Python

```python
from sb_stack_jsonrpc import JsonRpcServiceConfig
from sb_stack_transport_http import Http1TransportConfig
from sb_stack_transport_types import ConnectionConfig

transport_config = Http1TransportConfig(
    timeout=30.0,
    connection_config=ConnectionConfig(
        pool_max_idle_per_host=32,
        pool_idle_timeout=90.0,
        tcp_keepalive=60.0
    )
)

config = JsonRpcServiceConfig(
    "https://httpbin.org/post",
    error_handler=None,
    middlewares=None,
    transport_middlewares=None,
    transport_config=transport_config
)
```

#### 1.3 TypeScript

```typescript
import { JsonRpcServiceConfig } from 'sb-stack-jsonrpc';
import { Http1TransportConfig } from 'sb-stack-transport-http';
import { ConnectionConfig } from 'sb-stack-transport-types';

const transportConfig = new Http1TransportConfig({
    timeout: 30000,
    connectionConfig: new ConnectionConfig({
        poolMaxIdlePerHost: 32,
        poolIdleTimeout: 90000,
        tcpKeepalive: 60000
    })
});

const config = new JsonRpcServiceConfig(
    'https://httpbin.org/post',
    null,  // jsonrpc_middlewares
    null,  // transport_middlewares
    transportConfig,  // transport_config
    null   // error_handler
);
```