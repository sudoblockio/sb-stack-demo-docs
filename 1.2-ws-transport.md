# WebSocket Transport

This document describes a WebSocket implementation built on the same transport abstraction as HTTP. It provides bidirectional communication with pub/sub patterns, connection management, and middleware support in Rust, Python, and TypeScript.

## Architecture Overview

The WebSocket transport follows a bottom-to-top layered architecture, building from the core transport abstraction up to high-level client APIs:

```
┌─────────────────────────────────────────┐
│ Base Transport (sb-stack-transport)     │  ← Core abstraction
├─────────────────────────────────────────┤
│ WebSocket Transport                     │
│ (sb-stack-transport-ws)                 │  ← Protocol-specific implementation
│ (with optional middleware)              │
├─────────────────────────────────────────┤
│ WebSocket Client                        │
│ (sb-stack-ws-client)                    │  ← High-level API
└─────────────────────────────────────────┘
```

## Usage

### 1.1 Rust

```rust
use sb_stack_transport_ws::{WsTransport, WsTransportConfig, WsTransportFrame};
use url::Url;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let base_url = Url::parse("wss://echo.websocket.org")?;
    let mut transport = WsTransport::new(base_url, WsTransportConfig::default(), None);
    transport.connect().await?;

    let request = WsTransportFrame::text("Hello, WebSocket!");
    let response = transport.call(request).await?;

    println!("Echo: {:?}", response.as_text());

    Ok(())
}
```

### 1.2 Python

> **WIP**

### 1.3 TypeScript

> **WIP**

## Middleware

### 1.1 Rust

```rust
use sb_stack_transport_ws::{WsTransport, WsTransportConfig, WsTransportFrame};
use sb_stack_logging_middleware::{LoggingMiddleware, LogLevel};
use sb_stack_transport::BoxTransportLayerService;
use url::Url;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let logging = LoggingMiddleware::new(LogLevel::Info)
        .with_request_params(true)
        .with_response_results(true);

    let middlewares: Vec<BoxTransportLayerService<_, _>> = vec![
        Box::new(logging),
    ];

    let base_url = Url::parse("wss://echo.websocket.org")?;
    let mut transport = WsTransport::new(base_url, WsTransportConfig::default(), Some(middlewares));
    transport.connect().await?;

    let request = WsTransportFrame::text("Hello, WebSocket!");
    let response = transport.call(request).await?;

    println!("Echo: {:?}", response.as_text());

    Ok(())
}
```

### 1.2 Python

> **WIP**

### 1.3 TypeScript

> **WIP**

## Pub/Sub

```rust
use sb_stack_transport_ws::{WsTransport, WsTransportConfig, WsTransportFrame};
use url::Url;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let base_url = Url::parse("wss://echo.websocket.org")?;
    let mut transport = WsTransport::new(base_url, WsTransportConfig::default(), None);
    transport.connect().await?;

    let mut rx = transport.subscribe();

    let receiver_task = tokio::spawn(async move {
        while let Ok(frame) = rx.recv().await {
            if let Some(text) = frame.as_text() {
                println!("Received: {}", text);
            }
        }
    });

    transport.send(WsTransportFrame::text("Message 1")).await?;
    tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

    transport.send(WsTransportFrame::text("Message 2")).await?;
    tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

    transport.send(WsTransportFrame::text("Message 3")).await?;

    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    receiver_task.abort();

    Ok(())
}
```

## Configuration

The WebSocket transport supports comprehensive configuration options for connection management, reconnection, message handling, and subprotocol support.

### 1.1 Rust

```rust
use sb_stack_transport_ws::{WsTransport, WsTransportConfig};
use sb_stack_transport_types::TlsConfig;
use std::time::Duration;
use std::collections::HashMap;

let config = WsTransportConfig {
    read_buffer_size: 128 * 1024,
    write_buffer_size: 128 * 1024,
    max_write_buffer_size: usize::MAX,
    max_message_size: Some(64 << 20),
    max_frame_size: Some(16 << 20),
    accept_unmasked_frames: false,
    tls_config: TlsConfig::default(),
    connection_timeout: Duration::from_secs(30),
    read_timeout: None,
    write_timeout: Some(Duration::from_secs(10)),
    auto_reconnect: true,
    max_reconnect_attempts: Some(5),
    reconnect_delay: Duration::from_secs(1),
    max_reconnect_delay: Duration::from_secs(60),
    enable_keepalive: true,
    keepalive_interval: Duration::from_secs(30),
    keepalive_timeout: Duration::from_secs(10),
    protocols: vec!["".to_string()],
    headers: {
        let mut headers = HashMap::new();
        headers.insert("User-Agent".to_string(), "MyApp/1.0".to_string());
        headers
    },
};
```

### 1.2 Python

```python
from sb_stack_transport_ws import WsTransportConfig, TlsConfig

config = WsTransportConfig(
    read_buffer_size=128 * 1024,
    write_buffer_size=128 * 1024,
    max_write_buffer_size=2**31 - 1,
    max_message_size=64 * 1024 * 1024,
    max_frame_size=16 * 1024 * 1024,
    accept_unmasked_frames=False,
    tls_config=TlsConfig(),
    connection_timeout=30.0,
    read_timeout=None,
    write_timeout=10.0,
    auto_reconnect=True,
    max_reconnect_attempts=5,
    reconnect_delay=1.0,
    max_reconnect_delay=60.0,
    enable_keepalive=True,
    keepalive_interval=30.0,
    keepalive_timeout=10.0,
    protocols=["jsonrpc", "graphql-ws"],
    headers={
        "User-Agent": "MyApp/1.0"
    }
)
```

### 1.3 TypeScript

```typescript
import { WsTransportConfig, TlsConfig } from 'sb-stack-transport-ws';

const config = new WsTransportConfig({
    readBufferSize: 128 * 1024,
    writeBufferSize: 128 * 1024,
    maxWriteBufferSize: Number.MAX_SAFE_INTEGER,
    maxMessageSize: 64 * 1024 * 1024,
    maxFrameSize: 16 * 1024 * 1024,
    acceptUnmaskedFrames: false,
    tlsConfig: new TlsConfig(),
    connectionTimeout: 30000,
    readTimeout: null,
    writeTimeout: 10000,
    autoReconnect: true,
    maxReconnectAttempts: 5,
    reconnectDelay: 1000,
    maxReconnectDelay: 60000,
    enableKeepalive: true,
    keepaliveInterval: 30000,
    keepaliveTimeout: 10000,
    protocols: [''],
    headers: {
        'User-Agent': 'MyApp/1.0'
    }
});
```

### Configuration Options Summary

| Option | Description | Default |
|--------|-------------|---------|
| `read_buffer_size` | Read buffer size | 128KB |
| `write_buffer_size` | Write buffer size | 128KB |
| `max_message_size` | Maximum message size | 64MB |
| `max_frame_size` | Maximum frame size | 16MB |
| `connection_timeout` | Connection timeout | 30s |
| `read_timeout` | Read operation timeout | None |
| `write_timeout` | Write operation timeout | 10s |
| `auto_reconnect` | Enable automatic reconnection | true |
| `max_reconnect_attempts` | Maximum reconnection attempts | 5 |
| `reconnect_delay` | Initial reconnection delay | 1s |
| `max_reconnect_delay` | Maximum reconnection delay | 60s |
| `enable_keepalive` | Enable keepalive pings | true |
| `keepalive_interval` | Keepalive ping interval | 30s |
| `keepalive_timeout` | Keepalive timeout | 10s |
| `protocols` | WebSocket subprotocols | [] |
| `headers` | Custom headers | {} |
